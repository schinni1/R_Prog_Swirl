Selection: 13

  |                                                                                                                   |   0%

| One of the great advantages of using a statistical programming language like R is its vast collection of tools for
| simulating random numbers.

...

  |====                                                                                                               |   3%

| This lesson assumes familiarity with a few common probability distributions, but these topics will only be discussed with
| respect to random number generation. Even if you have no prior experience with these concepts, you should be able to
| complete the lesson and understand the main ideas.

...

  |=======                                                                                                            |   6%

| The first function we'll use to generate random numbers is sample(). Use ?sample to pull up the documentation.

> ?sample

| That's a job well done!

  |===========                                                                                                        |   9%

| Let's simulate rolling four six-sided dice: sample(1:6, 4, replace = TRUE).

> sample(1:6, 4, replace = TRUE)
[1] 5 1 2 3

| Excellent job!

  |==============                                                                                                     |  12%

| Now repeat the command to see how your result differs. (The probability of rolling the exact same result is (1/6)^4 =
| 0.00077, which is pretty small!)

> sample(1:6, 4, replace = TRUE)
[1] 3 2 1 2

| You nailed it! Good job!

  |==================                                                                                                 |  16%

| sample(1:6, 4, replace = TRUE) instructs R to randomly select four numbers between 1 and 6, WITH replacement. Sampling
| with replacement simply means that each number is "replaced" after it is selected, so that the same number can show up
| more than once. This is what we want here, since what you roll on one die shouldn't affect what you roll on any of the
| others.

...

  |======================                                                                                             |  19%

| Now sample 10 numbers between 1 and 20, WITHOUT replacement. To sample without replacement, simply leave off the 'replace'
| argument.

> sample(1:20, 10)
 [1]  5  4  3  1 16 11  6 18 12  9

| You are doing so well!

  |=========================                                                                                          |  22%

| Since the last command sampled without replacement, no number appears more than once in the output.

...

  |=============================                                                                                      |  25%

| LETTERS is a predefined variable in R containing a vector of all 26 letters of the English alphabet. Take a look at it
| now.

> LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"

| You're the best!

  |================================                                                                                   |  28%

| The sample() function can also be used to permute, or rearrange, the elements of a vector. For example, try
| sample(LETTERS) to permute all 26 letters of the English alphabet.

> sample(LETTERS)
 [1] "K" "Y" "M" "Z" "D" "E" "R" "H" "F" "J" "V" "C" "X" "Q" "G" "L" "O" "P" "T" "W" "B" "A" "U" "I" "S" "N"

| You nailed it! Good job!

  |====================================                                                                               |  31%

| This is identical to taking a sample of size 26 from LETTERS, without replacement. When the 'size' argument to sample() is
| not specified, R takes a sample equal in size to the vector from which you are sampling.

...

  |========================================                                                                           |  34%

| Now, suppose we want to simulate 100 flips of an unfair two-sided coin. This particular coin has a 0.3 probability of
| landing 'tails' and a 0.7 probability of landing 'heads'.

...

  |===========================================                                                                        |  38%

| Let the value 0 represent tails and the value 1 represent heads. Use sample() to draw a sample of size 100 from the vector
| c(0,1), with replacement. Since the coin is unfair, we must attach specific probabilities to the values 0 (tails) and 1
| (heads) with a fourth argument, prob = c(0.3, 0.7). Assign the result to a new variable called flips.

> flips <- sample(c(0,1), 100, pob =c(0.3, 0.7) )
Error in sample(c(0, 1), 100, pob = c(0.3, 0.7)) : 
  unused argument (pob = c(0.3, 0.7))
> flips <- sample(c(0,1), 100, prob =c(0.3, 0.7) )
Error in sample.int(length(x), size, replace, prob) : 
  cannot take a sample larger than the population when 'replace = FALSE'
> flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7) )

| You got it right!

  |===============================================                                                                    |  41%

| View the contents of the flips variable.

> flips
  [1] 0 0 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 1 0 0 1 1 1 0 1 1 1 1 1 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1
 [61] 1 1 0 0 1 0 1 1 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 0 1 0 1 1 1

| Keep up the great work!

  |==================================================                                                                 |  44%

| Since we set the probability of landing heads on any given flip to be 0.7, we'd expect approximately 70 of our coin flips
| to have the value 1. Count the actual number of 1s contained in flips using the sum() function.

> sum(flips)
[1] 73

| Excellent work!

  |======================================================                                                             |  47%

| A coin flip is a binary outcome (0 or 1) and we are performing 100 independent trials (coin flips), so we can use use
| rbinom() to simulate a binomial random variable. Pull up the documentation for rbinom() using ?rbinom.

> rbinor(flips)
Error: could not find function "rbinor"
> rbinom(flips)
Error in rbinom(flips) : argument "size" is missing, with no default
> ?rbinom

| Keep up the great work!

  |==========================================================                                                         |  50%

| Each probability distribution in R has an r*** function (for "random"), a d*** function (for "density"), a p*** (for
| "probability"), and q*** (for "quantile"). We are most interested in the r*** functions in this lesson, but I encourage
| you to explore the others on your own.

...

  |=============================================================                                                      |  53%

| A binomial random variable represents the number of 'successes' (heads) in a given number of independent 'trials' (coin
| flips). Therefore, we can generate a single random variable that represents the number of heads in 100 flips of our unfair
| coin using rbinom(1, size = 100, prob = 0.7). Note that you only specify the probability of 'success' (heads) and NOT the
| probability of 'failure' (tails). Try it now.

> rbinom(1, size = 100, prob = 0.7)
[1] 74

| You nailed it! Good job!

  |=================================================================                                                  |  56%

| Equivalently, if we want to see all of the 0s and 1s, we can request 100 observations, each of size 1, with success
| probability of 0.7. Give it a try, assigning the result to a new variable called flips2.

> rbinom(c(0,1), 100, prob = 0.7)
[1] 69 69

| Not exactly. Give it another go. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips <- rbinom(1, size = 100, prob = 0.7)

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips <- rbinom(100, size = 1, prob = 0.7)

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips2 <- rbinom(100, size = 1, prob = 0.7)

| Great job!

  |====================================================================                                               |  59%

| View the contents of flips2.

> flips2
  [1] 1 0 1 1 0 1 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 1 1 0 0 0 1 1 1 1 0 1 1 0 1 1 1 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1
 [61] 1 0 1 1 0 1 0 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 0 1

| All that hard work is paying off!

  |========================================================================                                           |  62%

| Now use sum() to count the number of 1s (heads) in flips2. It should be close to 70!
| Use ?tapply to pull up the documentation.

> ?tapply

| You are amazing!

  |========================================================================                                           |  62%

| The 'landmass' variable in our dataset takes on integer values between 1 and 6, each of which
| represents a different part of the world. Use table(flags$landmass) to see how many flags/countries
| fall into each group.

> table(flags$landmass)

 1  2  3  4  5  6 
31 17 35 52 39 20 

| Excellent job!

  |=============================================================================                                      |  67%

| The 'animate' variable in our dataset takes the value 1 if a country's flag contains an animate
| image (e.g. an eagle, a tree, a human hand) and 0 otherwise. Use table(flags$animate) to see how
| many flags contain an animate image.

> table(flags$animate)

  0   1 
155  39 

| All that hard work is paying off!

  |=================================================================================                                  |  71%

| This tells us that 39 flags contain an animate object (animate = 1) and 155 do not (animate = 0).

...

  |======================================================================================                             |  75%

| If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of 1s. Use
| tapply(flags$animate, flags$landmass, mean) to apply the mean function to the 'animate' variable
| separately for each of the six landmass groups, thus giving us the proportion of flags containing an
| animate image WITHIN each landmass group.

> 
> tapply(flags$animate, flags$landmass, mean)
        1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 

| Keep up the great work!

  |===========================================================================================                        |  79%

| The first landmass group (landmass = 1) corresponds to North America and contains the highest
| proportion of flags with an animate image (0.4194).

...

  |================================================================================================                   |  83%

| Similarly, we can look at a summary of population values (in round millions) for countries with and
| without the color red on their flag with tapply(flags$population, flags$red, summary).

> tapply(flags$population, flags$red, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    3.00   27.63    9.00  684.00 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0     0.0     4.0    22.1    15.0  1008.0 


| You're the best!

  |=====================================================================================================              |  88%

| What is the median population (in millions) for countries *without* the color red on their flag?

1: 22.1
2: 3.0
3: 0.0
4: 4.0
5: 9.0
6: 27.6

Selection: 2

| Keep working like that and you'll get there!

  |=========================================================================================================          |  92%

| Lastly, use the same approach to look at a summary of population values for each of the six landmasses.

> tapply(flags$population, flags$landmasses, summary)
Error in tapply(flags$population, flags$landmasses, summary) : 
  arguments must have same length
> tapply(flags$landmasses, flags$landmasses, summary)
Error in split.default(X, group) : first argument must be a vector
> tapply(flags$landmasses, flags$6, summary)
Error: unexpected numeric constant in "tapply(flags$landmasses, flags$6"
> tapply(flags$landmass, flags$6, summary)
Error: unexpected numeric constant in "tapply(flags$landmass, flags$6"
> tapply(flags$landmass, flags$six, summary)
Error in tapply(flags$landmass, flags$six, summary) : 
  arguments must have same length
> tapply(flags$population, flags$landmass, summary)
$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   12.29    4.50  231.00 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    6.00   15.71   15.00  119.00 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    8.00   13.86   16.00   61.00 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.000   5.000   8.788   9.750  56.000 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    2.00   10.00   69.18   39.00 1008.00 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   11.30    1.25  157.00 


| You are doing so well!

  |==============================================================================================================     |  96%

| What is the maximum population (in millions) for the fourth landmass group (Africa)?

1: 56.00
2: 1010.0
3: 5.00
4: 119.0
5: 157.00

Selection: 5

| Not quite, but you're learning! Try again.

| Use your result from the last question.

1: 1010.0
2: 5.00
3: 56.00
4: 157.00
5: 119.0

Selection: 1

| Not quite right, but keep trying.

| Use your result from the last question.

1: 56.00
2: 157.00
3: 119.0
4: 5.00
5: 1010.0

Selection: 1

| Nice work!

  |===================================================================================================================| 100%

| In this lesson, you learned how to use vapply() as a safer alternative to sapply(), which is most helpful when writing
| your own functions. You also learned how to use tapply() to split your data into groups based on the value of some
| variable, then apply a function to each group. These functions will come in handy on your quest to become a better data
| analyst.

...

| Are you currently enrolled in the Coursera course associated with this lesson?

1: Yes
2: No

Selection: 1

| Would you like me to notify Coursera that you've completed this lesson? If so, I'll need to get some more info from you.

1: Yes
2: No
3: Maybe later

Selection: 1

| Is the following information correct?

Course ID: rprog-013
Submission login (email): schinni1@gmail.com
Submission password: asgdxrzh4y

1: Yes, go ahead!
2: No, I need to change something.

Selection: 1

| I'll try to tell Coursera you've completed this lesson now.

| Great work!

| I've notified Coursera that you have completed rprog-013, vapply_and_tapply.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 12

  |                                                                                                                   |   0%

| Whenever you're working with a new dataset, the first thing you should do is look at it! What is the format of the data?
| What are the dimensions? What are the variable names? How are the variables stored? Are there missing data? Are there any
| flaws in the data?

...12

  |=====                                                                                                              |   4%

| This lesson will teach you how to answer these questions and more using R's built-in functions. We'll be using a dataset
| constructed from the United States Department of Agriculture's PLANTS Database (http://plants.usda.gov/adv_search.html).

...

  |==========                                                                                                         |   8%

| I've stored the data for you in a variable called plants. Type ls() to list the variables in your workspace, among which
| should be plants.

> ls()
 [1] "cls_list"    "cls_vect"    "data"        "e"           "flag_colors" "flag_shapes" "flags"       "ok"         
 [9] "plants"      "shape_mat"   "unique_vals" "viewinfo"    "x"           "y"          

| You are really on a roll!

  |==============                                                                                                     |  12%

| Let's begin by checking the class of the plants variable with class(plants). This will give us a clue as to the overall
| structure of the data.

> class(plants)
[1] "data.frame"

| Excellent job!

  |===================                                                                                                |  17%

| It's very common for data to be stored in a data frame. It is the default class for data read into R using functions like
| read.csv() and read.table(), which you'll learn about in another lesson.

...

  |========================                                                                                           |  21%

| Since the dataset is stored in a data frame, we know it is rectangular. In other words, it has two dimensions (rows and
| columns) and fits neatly into a table or spreadsheet. Use dim(plants) to see exactly how many rows and columns we're
| dealing with.

> dim(plants)
[1] 5166   10

| You nailed it! Good job!

  |=============================                                                                                      |  25%

| The first number you see (5166) is the number of rows (observations) and the second number (10) is the number of columns
| (variables).

...

  |==================================                                                                                 |  29%

| You can also use nrow(plants) to see only the number of rows. Try it out.

> nrow(plants)
[1] 5166

| You are really on a roll!

  |======================================                                                                             |  33%

| ... And ncol(plants) to see only the number of columns.

> ncol(plants)
[1] 10

| You got it right!

  |===========================================                                                                        |  38%

| If you are curious as to how much space the dataset is occupying in memory, you can use object.size(plants).

> object.size(plants)
644232 bytes

| Keep working like that and you'll get there!

  |================================================                                                                   |  42%

| Now that we have a sense of the shape and size of the dataset, let's get a feel for what's inside. names(plants) will
| return a character vector of column (i.e. variable) names. Give it a shot.

> names(plants)
 [1] "Scientific_Name"      "Duration"             "Active_Growth_Period" "Foliage_Color"        "pH_Min"              
 [6] "pH_Max"               "Precip_Min"           "Precip_Max"           "Shade_Tolerance"      "Temp_Min_F"          

| You got it!

  |=====================================================                                                              |  46%

| We've applied fairly descriptive variable names to this dataset, but that won't always be the case. A logical next step is
| to peek at the actual data. However, our dataset contains over 5000 observations (rows), so it's impractical to view the
| whole thing all at once.

...

  |==========================================================                                                         |  50%

| The head() function allows you to preview the top of the dataset. Give it a try with only one argument.

> head(plants)
               Scientific_Name          Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max
1                  Abelmoschus              <NA>                 <NA>          <NA>     NA     NA         NA         NA
2       Abelmoschus esculentus Annual, Perennial                 <NA>          <NA>     NA     NA         NA         NA
3                        Abies              <NA>                 <NA>          <NA>     NA     NA         NA         NA
4               Abies balsamea         Perennial    Spring and Summer         Green      4      6         13         60
5 Abies balsamea var. balsamea         Perennial                 <NA>          <NA>     NA     NA         NA         NA
6                     Abutilon              <NA>                 <NA>          <NA>     NA     NA         NA         NA
  Shade_Tolerance Temp_Min_F
1            <NA>         NA
2            <NA>         NA
3            <NA>         NA
4        Tolerant        -43
5            <NA>         NA
6            <NA>         NA

| You nailed it! Good job!

  |==============================================================                                                     |  54%

| Take a minute to look through and understand the output above. Each row is labeled with the observation number and each
| column with the variable name. Your screen is probably not wide enough to view all 10 columns side-by-side, in which case
| R displays as many columns as it can on each line before continuing on the next.

...

  |===================================================================                                                |  58%

| By default, head() shows you the first six rows of the data. You can alter this behavior by passing as a second argument
| the number of rows you'd like to view. Use head() to preview the first 10 rows of plants.

> head(plants,10)
                     Scientific_Name          Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min
1                        Abelmoschus              <NA>                 <NA>          <NA>     NA     NA         NA
2             Abelmoschus esculentus Annual, Perennial                 <NA>          <NA>     NA     NA         NA
3                              Abies              <NA>                 <NA>          <NA>     NA     NA         NA
4                     Abies balsamea         Perennial    Spring and Summer         Green      4    6.0         13
5       Abies balsamea var. balsamea         Perennial                 <NA>          <NA>     NA     NA         NA
6                           Abutilon              <NA>                 <NA>          <NA>     NA     NA         NA
7               Abutilon theophrasti            Annual                 <NA>          <NA>     NA     NA         NA
8                             Acacia              <NA>                 <NA>          <NA>     NA     NA         NA
9                  Acacia constricta         Perennial    Spring and Summer         Green      7    8.5          4
10 Acacia constricta var. constricta         Perennial                 <NA>          <NA>     NA     NA         NA
   Precip_Max Shade_Tolerance Temp_Min_F
1          NA            <NA>         NA
2          NA            <NA>         NA
3          NA            <NA>         NA
4          60        Tolerant        -43
5          NA            <NA>         NA
6          NA            <NA>         NA
7          NA            <NA>         NA
8          NA            <NA>         NA
9          20      Intolerant        -13
10         NA            <NA>         NA

| You are amazing!

  |========================================================================                                           |  62%

| The same applies for using tail() to preview the end of the dataset. Use tail() to view the last 15 rows.

> tail(plants)
      Scientific_Name  Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance
5161      Zizia aurea Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
5162 Zizia trifoliata Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
5163          Zostera      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
5164   Zostera marina Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
5165           Zoysia      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
5166  Zoysia japonica Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
     Temp_Min_F
5161         NA
5162         NA
5163         NA
5164         NA
5165         NA
5166         NA

| Not quite, but you're learning! Try again. Or, type info() for more options.

| tail(plants, 15) will show you the last 15 rows of the dataset.

> tail(plants,15)
                      Scientific_Name  Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max
5152                          Zizania      <NA>                 <NA>          <NA>     NA     NA         NA         NA
5153                 Zizania aquatica    Annual               Spring         Green    6.4    7.4         30         50
5154   Zizania aquatica var. aquatica    Annual                 <NA>          <NA>     NA     NA         NA         NA
5155                Zizania palustris    Annual                 <NA>          <NA>     NA     NA         NA         NA
5156 Zizania palustris var. palustris    Annual                 <NA>          <NA>     NA     NA         NA         NA
5157                      Zizaniopsis      <NA>                 <NA>          <NA>     NA     NA         NA         NA
5158             Zizaniopsis miliacea Perennial    Spring and Summer         Green    4.3    9.0         35         70
5159                            Zizia      <NA>                 <NA>          <NA>     NA     NA         NA         NA
5160                     Zizia aptera Perennial                 <NA>          <NA>     NA     NA         NA         NA
5161                      Zizia aurea Perennial                 <NA>          <NA>     NA     NA         NA         NA
5162                 Zizia trifoliata Perennial                 <NA>          <NA>     NA     NA         NA         NA
5163                          Zostera      <NA>                 <NA>          <NA>     NA     NA         NA         NA
5164                   Zostera marina Perennial                 <NA>          <NA>     NA     NA         NA         NA
5165                           Zoysia      <NA>                 <NA>          <NA>     NA     NA         NA         NA
5166                  Zoysia japonica Perennial                 <NA>          <NA>     NA     NA         NA         NA
     Shade_Tolerance Temp_Min_F
5152            <NA>         NA
5153      Intolerant         32
5154            <NA>         NA
5155            <NA>         NA
5156            <NA>         NA
5157            <NA>         NA
5158      Intolerant         12
5159            <NA>         NA
5160            <NA>         NA
5161            <NA>         NA
5162            <NA>         NA
5163            <NA>         NA
5164            <NA>         NA
5165            <NA>         NA
5166            <NA>         NA

| All that hard work is paying off!

  |=============================================================================                                      |  67%

| After previewing the top and bottom of the data, you probably noticed lots of NAs, which are R's placeholders for missing
| values. Use summary(plants) to get a better feel for how each variable is distributed and how much of the dataset is
| missing.

> summary(plants)
                     Scientific_Name              Duration              Active_Growth_Period      Foliage_Color 
 Abelmoschus                 :   1   Perennial        :3031   Spring and Summer   : 447      Dark Green  :  82  
 Abelmoschus esculentus      :   1   Annual           : 682   Spring              : 144      Gray-Green  :  25  
 Abies                       :   1   Annual, Perennial: 179   Spring, Summer, Fall:  95      Green       : 692  
 Abies balsamea              :   1   Annual, Biennial :  95   Summer              :  92      Red         :   4  
 Abies balsamea var. balsamea:   1   Biennial         :  57   Summer and Fall     :  24      White-Gray  :   9  
 Abutilon                    :   1   (Other)          :  92   (Other)             :  30      Yellow-Green:  20  
 (Other)                     :5160   NA's             :1030   NA's                :4334      NA's        :4334  
     pH_Min          pH_Max         Precip_Min      Precip_Max         Shade_Tolerance   Temp_Min_F    
 Min.   :3.000   Min.   : 5.100   Min.   : 4.00   Min.   : 16.00   Intermediate: 242   Min.   :-79.00  
 1st Qu.:4.500   1st Qu.: 7.000   1st Qu.:16.75   1st Qu.: 55.00   Intolerant  : 349   1st Qu.:-38.00  
 Median :5.000   Median : 7.300   Median :28.00   Median : 60.00   Tolerant    : 246   Median :-33.00  
 Mean   :4.997   Mean   : 7.344   Mean   :25.57   Mean   : 58.73   NA's        :4329   Mean   :-22.53  
 3rd Qu.:5.500   3rd Qu.: 7.800   3rd Qu.:32.00   3rd Qu.: 60.00                       3rd Qu.:-18.00  
 Max.   :7.000   Max.   :10.000   Max.   :60.00   Max.   :200.00                       Max.   : 52.00  
 NA's   :4327    NA's   :4327     NA's   :4338    NA's   :4338                         NA's   :4328    

| That's a job well done!

  |=================================================================================                                  |  71%

| summary() provides different output for each variable, depending on its class. For numeric data such as Precip_Min,
| summary() displays the minimum, 1st quartile, median, mean, 3rd quartile, and maximum. These values help us understand how
| the data are distributed.

...

  |======================================================================================                             |  75%

| For categorical variables (called 'factor' variables in R), summary() displays the number of times each value (or 'level')
| occurs in the data. For example, each value of Scientific_Name only appears once, since it is unique to a specific plant.
| In contrast, the summary for Duration (also a factor variable) tells us that our dataset contains 3031 Perennial plants,
| 682 Annual plants, etc.

...

  |===========================================================================================                        |  79%

| You can see that R truncated the summary for Active_Growth_Period by including a catch-all category called 'Other'. Since
| it is a categorical/factor variable, we can see how many times each value actually occurs in the data with
| table(plants$Active_Growth_Period).

> table(plants$Active_Growth_Period)

Fall, Winter and Spring                  Spring         Spring and Fall       Spring and Summer    Spring, Summer, Fall 
                     15                     144                      10                     447                      95 
                 Summer         Summer and Fall              Year Round 
                     92                      24                       5 

| That's correct!

  |================================================================================================                   |  83%

| Each of the functions we've introduced so far has its place in helping you to better understand the structure of your
| data. However, we've left the best for last....

...

  |=====================================================================================================              |  88%

| Perhaps the most useful and concise function for understanding the *str*ucture of your data is str(). Give it a try now.

> str(plants)
'data.frame':	5166 obs. of  10 variables:
 $ Scientific_Name     : Factor w/ 5166 levels "Abelmoschus",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ Duration            : Factor w/ 8 levels "Annual","Annual, Biennial",..: NA 4 NA 7 7 NA 1 NA 7 7 ...
 $ Active_Growth_Period: Factor w/ 8 levels "Fall, Winter and Spring",..: NA NA NA 4 NA NA NA NA 4 NA ...
 $ Foliage_Color       : Factor w/ 6 levels "Dark Green","Gray-Green",..: NA NA NA 3 NA NA NA NA 3 NA ...
 $ pH_Min              : num  NA NA NA 4 NA NA NA NA 7 NA ...
 $ pH_Max              : num  NA NA NA 6 NA NA NA NA 8.5 NA ...
 $ Precip_Min          : int  NA NA NA 13 NA NA NA NA 4 NA ...
 $ Precip_Max          : int  NA NA NA 60 NA NA NA NA 20 NA ...
 $ Shade_Tolerance     : Factor w/ 3 levels "Intermediate",..: NA NA NA 3 NA NA NA NA 2 NA ...
 $ Temp_Min_F          : int  NA NA NA -43 NA NA NA NA -13 NA ...

| That's a job well done!

  |=========================================================================================================          |  92%

| The beauty of str() is that it combines many of the features of the other functions you've already seen, all in a concise
| and readable format. At the very top, it tells us that the class of plants is 'data.frame' and that it has 5166
| observations and 10 variables. It then gives us the name and class of each variable, as well as a preview of its contents.

...

  |==============================================================================================================     |  96%

| str() is actually a very general function that you can use on most objects in R. Any time you want to understand the
| structure of something (a dataset, function, etc.), str() is a good place to start.

...str()

  |===================================================================================================================| 100%

| In this lesson, you learned how to get a feel for the structure and contents of a new dataset using a collection of simple
| and useful functions. Taking the time to do this upfront can save you time and frustration later on in your analysis.

...

| Are you currently enrolled in the Coursera course associated with this lesson?

1: Yes
2: No

Selection: 1

| Would you like me to notify Coursera that you've completed this lesson? If so, I'll need to get some more info from you.

1: Yes
2: No
3: Maybe later

Selection: 1

| Is the following information correct?

Course ID: rprog-013
Submission login (email): schinni1@gmail.com
Submission password: asgdxrzh4y

1: Yes, go ahead!
2: No, I need to change something.

Selection: 1

| I'll try to tell Coursera you've completed this lesson now.

| Great work!

| I've notified Coursera that you have completed rprog-013, Looking_at_Data.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 13

  |                                                                                                                   |   0%

| One of the great advantages of using a statistical programming language like R is its vast collection of tools for
| simulating random numbers.

...

  |====                                                                                                               |   3%

| This lesson assumes familiarity with a few common probability distributions, but these topics will only be discussed with
| respect to random number generation. Even if you have no prior experience with these concepts, you should be able to
| complete the lesson and understand the main ideas.

...

  |=======                                                                                                            |   6%

| The first function we'll use to generate random numbers is sample(). Use ?sample to pull up the documentation.

> ?sample

| That's a job well done!

  |===========                                                                                                        |   9%

| Let's simulate rolling four six-sided dice: sample(1:6, 4, replace = TRUE).

> sample(1:6, 4, replace = TRUE)
[1] 5 1 2 3

| Excellent job!

  |==============                                                                                                     |  12%

| Now repeat the command to see how your result differs. (The probability of rolling the exact same result is (1/6)^4 =
| 0.00077, which is pretty small!)

> sample(1:6, 4, replace = TRUE)
[1] 3 2 1 2

| You nailed it! Good job!

  |==================                                                                                                 |  16%

| sample(1:6, 4, replace = TRUE) instructs R to randomly select four numbers between 1 and 6, WITH replacement. Sampling
| with replacement simply means that each number is "replaced" after it is selected, so that the same number can show up
| more than once. This is what we want here, since what you roll on one die shouldn't affect what you roll on any of the
| others.

...

  |======================                                                                                             |  19%

| Now sample 10 numbers between 1 and 20, WITHOUT replacement. To sample without replacement, simply leave off the 'replace'
| argument.

> sample(1:20, 10)
 [1]  5  4  3  1 16 11  6 18 12  9

| You are doing so well!

  |=========================                                                                                          |  22%

| Since the last command sampled without replacement, no number appears more than once in the output.

...

  |=============================                                                                                      |  25%

| LETTERS is a predefined variable in R containing a vector of all 26 letters of the English alphabet. Take a look at it
| now.

> LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"

| You're the best!

  |================================                                                                                   |  28%

| The sample() function can also be used to permute, or rearrange, the elements of a vector. For example, try
| sample(LETTERS) to permute all 26 letters of the English alphabet.

> sample(LETTERS)
 [1] "K" "Y" "M" "Z" "D" "E" "R" "H" "F" "J" "V" "C" "X" "Q" "G" "L" "O" "P" "T" "W" "B" "A" "U" "I" "S" "N"

| You nailed it! Good job!

  |====================================                                                                               |  31%

| This is identical to taking a sample of size 26 from LETTERS, without replacement. When the 'size' argument to sample() is
| not specified, R takes a sample equal in size to the vector from which you are sampling.

...

  |========================================                                                                           |  34%

| Now, suppose we want to simulate 100 flips of an unfair two-sided coin. This particular coin has a 0.3 probability of
| landing 'tails' and a 0.7 probability of landing 'heads'.

...

  |===========================================                                                                        |  38%

| Let the value 0 represent tails and the value 1 represent heads. Use sample() to draw a sample of size 100 from the vector
| c(0,1), with replacement. Since the coin is unfair, we must attach specific probabilities to the values 0 (tails) and 1
| (heads) with a fourth argument, prob = c(0.3, 0.7). Assign the result to a new variable called flips.

> flips <- sample(c(0,1), 100, pob =c(0.3, 0.7) )
Error in sample(c(0, 1), 100, pob = c(0.3, 0.7)) : 
  unused argument (pob = c(0.3, 0.7))
> flips <- sample(c(0,1), 100, prob =c(0.3, 0.7) )
Error in sample.int(length(x), size, replace, prob) : 
  cannot take a sample larger than the population when 'replace = FALSE'
> flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7) )

| You got it right!

  |===============================================                                                                    |  41%

| View the contents of the flips variable.

> flips
  [1] 0 0 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 1 0 0 1 1 1 0 1 1 1 1 1 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1
 [61] 1 1 0 0 1 0 1 1 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 0 1 0 1 1 1

| Keep up the great work!

  |==================================================                                                                 |  44%

| Since we set the probability of landing heads on any given flip to be 0.7, we'd expect approximately 70 of our coin flips
| to have the value 1. Count the actual number of 1s contained in flips using the sum() function.

> sum(flips)
[1] 73

| Excellent work!

  |======================================================                                                             |  47%

| A coin flip is a binary outcome (0 or 1) and we are performing 100 independent trials (coin flips), so we can use use
| rbinom() to simulate a binomial random variable. Pull up the documentation for rbinom() using ?rbinom.

> rbinor(flips)
Error: could not find function "rbinor"
> rbinom(flips)
Error in rbinom(flips) : argument "size" is missing, with no default
> ?rbinom

| Keep up the great work!

  |==========================================================                                                         |  50%

| Each probability distribution in R has an r*** function (for "random"), a d*** function (for "density"), a p*** (for
| "probability"), and q*** (for "quantile"). We are most interested in the r*** functions in this lesson, but I encourage
| you to explore the others on your own.

...

  |=============================================================                                                      |  53%

| A binomial random variable represents the number of 'successes' (heads) in a given number of independent 'trials' (coin
| flips). Therefore, we can generate a single random variable that represents the number of heads in 100 flips of our unfair
| coin using rbinom(1, size = 100, prob = 0.7). Note that you only specify the probability of 'success' (heads) and NOT the
| probability of 'failure' (tails). Try it now.

> rbinom(1, size = 100, prob = 0.7)
[1] 74

| You nailed it! Good job!

  |=================================================================                                                  |  56%

| Equivalently, if we want to see all of the 0s and 1s, we can request 100 observations, each of size 1, with success
| probability of 0.7. Give it a try, assigning the result to a new variable called flips2.

> rbinom(c(0,1), 100, prob = 0.7)
[1] 69 69

| Not exactly. Give it another go. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips <- rbinom(1, size = 100, prob = 0.7)

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips <- rbinom(100, size = 1, prob = 0.7)

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

> flips2 <- rbinom(100, size = 1, prob = 0.7)

| Great job!

  |====================================================================                                               |  59%

| View the contents of flips2.

> flips2
  [1] 1 0 1 1 0 1 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 1 1 0 0 0 1 1 1 1 0 1 1 0 1 1 1 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1
 [61] 1 0 1 1 0 1 0 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 0 1

| All that hard work is paying off!

  |========================================================================                                           |  62%

| Now use sum() to count the number of 1s (heads) in flips2. It should be close to 70!

> sum(flips2, ls(heads))
Error in as.environment(pos) : no item called "heads" on the search list
In addition: Warning message:
In ls(heads) : ‘heads’ converted to character string
> sum(flips2)
[1] 68

| You got it right!

  |===========================================================================                                        |  66%

| Similar to rbinom(), we can use R to simulate random numbers from many other probability distributions. Pull up the
| documentation for rnorm() now.

> rnorm()
Error in rnorm() : argument "n" is missing, with no default
> ?rnorm

| Great job!

  |===============================================================================                                    |  69%

| The standard normal distribution has mean 0 and standard deviation 1. As you can see under the 'Usage' section in the
| documentation, the default values for the 'mean' and 'sd' arguments to rnorm() are 0 and 1, respectively. Thus, rnorm(10)
| will generate 10 random numbers from a standard normal distribution. Give it a try.

> rnorm(10)
 [1]  0.8237898  0.5977866  1.2956375 -0.5780662  0.1729750 -0.5811962 -0.7825906 -1.6668292 -0.7134732 -0.5066758

| Excellent job!

  |===================================================================================                                |  72%

| Now do the same, except with a mean of 100 and a standard deviation of 25.

> rnorm(10, mean = 100, sd = 25)
 [1] 101.82477 123.96958 163.24772  87.67379 110.24726 145.30403  63.60050 116.20528 109.65678  90.22647

| Perseverance, that's the answer.

  |======================================================================================                             |  75%

| Finally, what if we want to simulate 100 *groups* of random numbers, each containing 5 values generated from a Poisson
| distribution with mean 10? Let's start with one group of 5 numbers, then I'll show you how to repeat the operation 100
| times in a convenient and compact way.

...

  |==========================================================================================                         |  78%

| Generate 5 random values from a Poisson distribution with mean 10. Check out the documentation for rpois() if you need
| help.

> ?rpois
> rpois(5, 10)
[1]  9 12 14  9  8

| That's correct!

  |=============================================================================================                      |  81%

| Now use replicate(100, rpois(5, 10)) to perform this operation 100 times. Store the result in a new variable called
| my_pois.

> my_pois <- replicate(100, rpois(5, 10))

| You are quite good my friend!

  |=================================================================================================                  |  84%

| Take a look at the contents of my_pois.

> my_pois
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21]
[1,]    8    5   12   13   13   10   11   13    9     7     8     8     6    17     6     6     5    13    13    11    11
[2,]   14   15   14   11   10   15   13    8    6    11     9    14    14    11    14    13     7     5     7    12     9
[3,]    7   12   12    6   13    5    9    6    5    16    12    10    10     4    11    18    14     6     9     8    12
[4,]    7   13   10   12    8    8    7    8    8    11    22    14    15    17     6     8    10    16    13    10    12
[5,]   13   14    6    8    6   12   10    8   11    13     5    16    12     9     9     8     7    12     6     8     8
     [,22] [,23] [,24] [,25] [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40] [,41]
[1,]    16     6    15     4     8     9     7     3    15     7    15     5    12    13    11     7     9    12    11    14
[2,]     5    14    10    19     9    13    18    10    13     3    16    13    11    12     9     6    12     7    13     7
[3,]    10     8     8     9     9    22     8    15     6    13    10    17     8     7    14    10     8     7    16    15
[4,]     6     9     7     9    11    11    11     9    15    10    12    13     7    12    11     9     9     9    10     9
[5,]    17    13    10    11     9    11    14     6     6     8    14    12    12     8    10     6     6    11    13    15
     [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50] [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61]
[1,]     6     5    13     6     8    10    10     9     7     9    10     3     9    10    13    12    12     8     7    14
[2,]    10    16     9    11    17    14     7     5    13     5     9    10    10     9    13    12     9    12     9    13
[3,]    12    11    13    13    11     4     9    16     8    10    11     9    13     6     7    10     9    19    11     8
[4,]    11    10     9     4    10     6     9     6    10    14    12    14     5    10     9    14     8     9    14    10
[5,]     9    17     8    10    10    11    13    12     9    11    10     3     8    11     7    13    11    13     7     9
     [,62] [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74] [,75] [,76] [,77] [,78] [,79] [,80] [,81]
[1,]    15    12     8    14    14     7     9     4    11    13    15     8    11    12     8    10    10    12     8    12
[2,]    14    10    14    15     5    11     5    15     6    11    12    15     6    15     9     9    15    16     8    10
[3,]     9     6     9     3     7    17     8    14    15     8     7    15    10     7    12     7     8     6    10     6
[4,]    15     8    13     9    12    19    14     9     9     6    11    10    15     4     9    10    12     5    12    11
[5,]     7    12     5    13    11    13    15    10    11    14     5     7     9    13     6    10    11     8     7    14
     [,82] [,83] [,84] [,85] [,86] [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98] [,99] [,100]
[1,]     8    10    14     6     9     7     6    12     7    14    10    11    12     9     4     7     7     9     13
[2,]    11    11     9    12    10    14    13    11     9    10    13    11    11    14    10    11    16    14     13
[3,]     8     9     9     7    10    13    10     7    14    14    12    10    11    13     6     9     9    11     14
[4,]    12    15     8     5    12     9     9     6     7    13    10    11    15     7     6    13    13    18     11
[5,]     7    11    16     8    12    11    11    12    16     5    13     5    10     9    11     8     6     7      8

| That's a job well done!

  |=====================================================================================================              |  88%

| replicate() created a matrix, each column of which contains 5 random numbers generated from a Poisson distribution with
| mean 10. Now we can find the mean of each column in my_pois using the colMeans() function. Store the result in a variable
| called cm.

> colMeans(my_pois)
  [1]  9.8 11.8 10.8 10.0 10.0 10.0 10.0  8.6  7.8 11.6 11.2 12.4 11.4 11.6  9.2 10.6  8.6 10.4  9.6  9.8 10.4 10.8 10.0 10.0
 [25] 10.4  9.2 13.2 11.6  8.6 11.0  8.2 13.4 12.0 10.0 10.4 11.0  7.6  8.8  9.2 12.6 12.0  9.6 11.8 10.4  8.8 11.2  9.0  9.6
 [49]  9.6  9.4  9.8 10.4  7.8  9.0  9.2  9.8 12.2  9.8 12.2  9.6 10.8 12.0  9.6  9.8 10.8  9.8 13.4 10.2 10.4 10.4 10.4 10.0
 [73] 11.0 10.2 10.2  8.8  9.2 11.2  9.4  9.0 10.6  9.2 11.2 11.2  7.6 10.6 10.8  9.8  9.6 10.6 11.2 11.6  9.6 11.8 10.4  7.4
 [97]  9.6 10.2 11.8 11.8

| Almost! Try again. Or, type info() for more options.

| Use cm <- colMeans(my_pois) to create a vector of column means, storing the result in cm.

> cm <- colMeans(my_pois)

| All that practice is paying off!

  |========================================================================================================           |  91%

| And let's take a look at the distribution of our column means by plotting a histogram with hist(cm).

> cm
  [1]  9.8 11.8 10.8 10.0 10.0 10.0 10.0  8.6  7.8 11.6 11.2 12.4 11.4 11.6  9.2 10.6  8.6 10.4  9.6  9.8 10.4 10.8 10.0 10.0
 [25] 10.4  9.2 13.2 11.6  8.6 11.0  8.2 13.4 12.0 10.0 10.4 11.0  7.6  8.8  9.2 12.6 12.0  9.6 11.8 10.4  8.8 11.2  9.0  9.6
 [49]  9.6  9.4  9.8 10.4  7.8  9.0  9.2  9.8 12.2  9.8 12.2  9.6 10.8 12.0  9.6  9.8 10.8  9.8 13.4 10.2 10.4 10.4 10.4 10.0
 [73] 11.0 10.2 10.2  8.8  9.2 11.2  9.4  9.0 10.6  9.2 11.2 11.2  7.6 10.6 10.8  9.8  9.6 10.6 11.2 11.6  9.6 11.8 10.4  7.4
 [97]  9.6 10.2 11.8 11.8

| That's not the answer I was looking for, but try again. Or, type info() for more options.

| hist(cm) will give you a histogram of column means.

> hist(cm)

| You are amazing!

  |============================================================================================================       |  94%

| Looks like our column means are almost normally distributed, right? That's the Central Limit Theorem at work, but that's a
| lesson for another day!

...

  |===============================================================================================================    |  97%

| All of the standard probability distributions are built into R, including exponential (rexp()), chi-squared (rchisq()),
| gamma (rgamma()), .... Well, you see the pattern.

...

  |===================================================================================================================| 100%

| Simulation is practically a field of its own and we've only skimmed the surface of what's possible. I encourage you to
| explore these and other functions further on your own.

...

| Are you currently enrolled in the Coursera course associated with this lesson?

1: Yes
2: No
